class Plexus {
    static = {
        mimeTypes = {};
        deviceWhitelist = {"computer", "turtle", "drive"};
    };

    history = {
        offset = 0;
        entries = {};
    };

    peripherals = {};

    location = "/";
    computerID = false;
}

function Plexus:__init__( pwd )
    if type( pwd ) ~= "string" then
        return error("Plexus constructor requires a string path representing starting location. '"..tostring( pwd ).."' is invalid.")
    end

    self.computerID = computerID
    self.location = Plexus.static.cleanPath( pwd )
end

--[[
    @instance
    @desc Navigate through the Plexus instance history
    @param <number - direction>

    Note: If number (direction) is positive, attempts will be made to move forward through the history. If number is negative, the opposite holds true.
]]
function Plexus:historyNavigate( offset )
    local hOffset, offset = self.history.offset, offset or 0

    if offset > 0 and hOffset == 0 then
        return error "Attempt to navigate forward past history end point"
    elseif offset < 0 and hOffset == #self.history.entries then
        return error "Attempt to navigate backward past history start point"
    else
        self.history.offset = hOffset + offset
    end
end

--[[
    @static
    @desc Cleans a file system path by removing anomolies that will likely cause problems when using the filesystem commands
    @param <string - path>
    @return <string - path>
]]
function Plexus.static.cleanPath( path )
    return path
            :gsub("^%./", "") -- Remove trailing ./
            :gsub("/%./", "/") -- Replace ./ inside path with /
            :gsub("\\", "/") -- Replace \ with /
            :gsub("//+", "/") -- Remove duplicate slashes
            :gsub("/+$", "") -- Remove trailing slashes
end

--[[
    @static
    @desc 'Explode' the path provided into 'parts' that represent directories
    @param <string - uncleanPath>
    @return <table - parts>, <string - cleanPath>
]]
function Plexus.static.splitPath( path )
    local parts, path = {}, Plexus.static.cleanPath( path )
    for part in path:gmatch "([^/]+)/?" do
        parts[ #parts + 1 ] = part
    end

    return parts, path
end

--[[
    @static
    @desc Returns the final part of the extension for 'path'
    @param <string - cleanPath>
    @return <string - extension>
]]
function Plexus.static.getExtension( path )
    return path:match ".+%.(.-)$" or ""
end

--[[
    @static
    @desc Registers mime type 'mime', with the extensions provided. Previous extensions bound to mime type are preserved
    @param <string - mime>, [string (vararg) - extensions]

    Note: 'extensions' represents the file extensions to associate with this mime type
]]
function Plexus.static.registerMime( mime, ... )
    local extensions, existing, ext = { ... }, Plexus.mimeTypes[ mime ] or {}
    for i = 1, #extensions do
        ext = extensions[ i ]
        if not util.isInTable( existing, ext ) then
            existing[ #existing + 1 ] = ext
        end
    end

    Plexus.mimeTypes[ mime ] = existing
end

--[[
    @static
    @desc Returns the mime type associated with the extension of 'path'.
    @param <string - path>
    @return [string - mime]
]]
function Plexus.static.determineMime( path )
    local ext, mimes = Plexus.static.getExtension( path ), Plexus.mimeTypes
    for mime, exts in pairs( mimes ) do
        for e = 1, #exts do
            if exts[ e ] == ext then
                return mime
            end
        end
    end
end

--[[
    @static
    @desc Adds the input device type to the deviceWhitelist table.
    @param <string - device>
]]
function Plexus.static.whitelistDevice( device )
    if type( device ) ~= "string" then
        table.insert( self.static.deviceWhitelist, device )
    else
        return error "Failed to whitelist peripheral. Invalid peripheral type provided"
    end
end

--[[
    @static
    @desc Adds currently connected, whitelisted devices to the peripherals table.
]]
function Plexus.static.discoverPeripherals()
    local sides = {"top", "bottom", "left", "right", "front", "back"}
    local types = {}
    for _, side in ipairs( sides ) do
        if peripheral.isPresent(side) then
            local devType = peripheral.getType( side )
            for _, whited in ipairs( self.static.deviceWhitelist ) do
                if devType == whited then
                    table.insert( self.peripherals, {devType, side} )
                    break
                end
            end
        end
    end
end
